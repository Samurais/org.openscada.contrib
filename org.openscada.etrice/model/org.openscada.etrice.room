RoomModel org.openscada.etrice {
	
	import room.basic.types.* from "platform:/resource/org.eclipse.etrice.modellib.java/models/Types.room"
	
	ActorClass NamedClientDataItem {
		
		Interface {
			Port item : ClientItemProtocol
		}
		
		Structure {
			
			usercode1 {
				"import org.openscada.etrice.ConnectionManagerWrapper;"
				"import org.openscada.da.client.DataItem;"
				"import org.openscada.core.VariantEditor;"
			}
			
			usercode2 {
				"private ConnectionManagerWrapper wrapper;"
				"private DataItem dataItem;"
			}
			
			external Port item
			
			Attribute connectionUri : string
			Attribute itemId : string
		}
		
		Behavior {
			Operation initUser () {
				"this.wrapper = new ConnectionManagerWrapper ();"
				"this.dataItem = wrapper.getConnectionManager().getItem ( this.connectionUri, this.itemId, this.item );"
			}
			Operation destroyUser () {
				"this.wrapper.dispose ();"
				"this.wrapper = null;"
			}
			StateMachine{
				Transition init: initial -> initialized { }
				
				Transition doWrite: initialized -> initialized {
					triggers {
						<write: item>
					}
					action{
						"this.wrapper.getConnectionManager().write ( this.connectionUri, this.itemId, VariantEditor.toVariant ( value ));"
					}
				}
				
				State initialized
			}
		}
	}
	
 	ActorClass NamedServerDataItem {
		
		Interface {
			Port item : ServerItemProtocol
		}
		Structure {
			usercode1{
				"import org.openscada.da.server.common.chain.DataItemInputOutputChained;"
				"import org.openscada.core.VariantEditor;"
			}
			usercode2 {
				"private HiveWrapper hiveWrapper;"
				"private DataItemInputOutputChained dataItem;"
			}
			
			external Port item
			
			Attribute itemId : string
		}
		Behavior {
			Operation initUser () {
				"this.hiveWrapper =  new HiveWrapper ();"
				"this.dataItem = this.hiveWrapper.getHive ().registerItem ( itemId, this.item);"
			}
			Operation destroyUser () {
				"if ( this.dataItem != null ) {"
				"  this.hiveWrapper.getHive ().unregisterItem ( this.dataItem );"
				"  this.dataItem = null; }"
				
				"this.hiveWrapper.dispose ();"
				"this.hiveWrapper = null;"
				 
				
			}
			StateMachine {
				Transition init: initial -> registered { }
				Transition doUpdate : registered -> registered {
					triggers {
						<update: item>
					}
					action{
						"this.dataItem.updateData ( VariantEditor.toVariant ( value ), null, null );"
					}
				}
				State registered
			}
		}
	}
	
 	ActorClass RegisteredServerDataItem {
		
		Interface {
			Port registration : RegisterItemProtocol
			Port item : ServerItemProtocol
		}
		Structure {
			usercode1{
				"import org.openscada.da.server.common.chain.DataItemInputOutputChained;"
				"import org.openscada.core.VariantEditor;"
			}
			usercode2 {
				"private HiveWrapper hiveWrapper;"
				"private DataItemInputOutputChained dataItem;"
			}
			external Port registration
			external Port item
		}
		Behavior {
			Operation initUser () {
				"this.hiveWrapper =  new HiveWrapper ();"
			}
			Operation destroyUser () {
				"if ( this.dataItem != null ) {"
				"  this.hiveWrapper.getHive ().unregisterItem ( this.dataItem );"
				"  this.dataItem = null; }"
				
				"this.hiveWrapper.dispose ();"
				"this.hiveWrapper = null;"
				
			}
			StateMachine {
				Transition init: initial -> unconfigured { }
				Transition doRegister: unconfigured -> registered {
					triggers {
						<register: registration>
					}
					action {
						"this.dataItem = this.hiveWrapper.getHive ().registerItem ( itemName, this.item);"
					}
				}
				Transition doUpdate : registered -> registered {
					triggers {
						<update: item>
					}
					action{
						"this.dataItem.updateData ( VariantEditor.toVariant ( value ), null, null );"
					}
				}
				State registered
				State unconfigured
			}
		}
	}
	
	ProtocolClass RegisterItemProtocol {
		incoming {
			Message register ( itemName : string )
		}
	}
	
	ProtocolClass ServerItemProtocol {
		incoming {
			Message update ( value : string )
		}
		outgoing {
			Message writeCall ( value : string )
		}
	}
	
	ProtocolClass ClientItemProtocol {
		incoming {
			Message write ( value : string )
		}
		outgoing {
			Message updateValue ( value : string )
			Message updateState ( connected : boolean )
		}
	}
}